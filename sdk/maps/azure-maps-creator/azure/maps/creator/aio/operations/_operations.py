# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, List, Optional, TypeVar, Union, cast

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.polling.async_base_polling import AsyncLROBasePolling
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ...operations._operations import build_alias_assign_request, build_alias_create_request, build_alias_delete_request, build_alias_get_request, build_alias_list_request, build_conversion_convert_request_initial, build_conversion_delete_request, build_conversion_get_operation_request, build_conversion_get_request, build_conversion_list_request, build_data_delete_request, build_data_download_request, build_data_get_operation_request, build_data_list_request, build_data_update_request_initial, build_data_upload_request_initial, build_dataset_create_request_initial, build_dataset_delete_request, build_dataset_get_operation_request, build_dataset_get_request, build_dataset_list_request, build_feature_state_create_stateset_request, build_feature_state_delete_state_request, build_feature_state_delete_stateset_request, build_feature_state_get_stateset_request, build_feature_state_list_states_request, build_feature_state_list_statesets_request, build_feature_state_update_states_request, build_feature_state_update_stateset_request, build_spatial_evaluate_point_in_polygon_request, build_spatial_get_buffer_request, build_spatial_get_closest_point_request, build_spatial_get_geofence_request, build_spatial_get_great_circle_distance_request, build_spatial_post_buffer_request, build_spatial_post_closest_point_request, build_spatial_post_geofence_request, build_spatial_post_point_in_polygon_request, build_tileset_create_request_initial, build_tileset_delete_request, build_tileset_get_operation_request, build_tileset_get_request, build_tileset_list_request, build_wfs_delete_feature_request, build_wfs_get_collection_definition_request, build_wfs_get_collection_request, build_wfs_get_collections_request, build_wfs_get_feature_request, build_wfs_get_features_request, build_wfs_get_landing_page_request, build_wfs_list_conformance_request
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any] # pylint: disable=unsubscriptable-object
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AliasOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`alias` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def create(
        self,
        *,
        creator_data_item_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to create an alias. You can also assign the alias during the create
        request. An alias can reference an ID generated by a creator service, but cannot reference
        another alias ID.

        Submit Create Request
        ^^^^^^^^^^^^^^^^^^^^^

        To create your alias, you will use a ``POST`` request. If you would like to assign the alias
        during the creation, you will pass the ``resourceId`` query parameter.

        Create Alias Response
        ^^^^^^^^^^^^^^^^^^^^^

        The Create API returns a HTTP ``201 Created`` response with the alias resource in the body.

        A sample response from creating an alias:

        .. code-block:: json

           {
             "createdTimestamp": "2020-02-13T21:19:11.123Z",
             "aliasId": "a8a4b8bb-ecf4-fb27-a618-f41721552766",
             "creatorDataItemId": "e89aebb9-70a3-8fe1-32bb-1fbd0c725f14",
             "lastUpdatedTimestamp": "2020-02-13T21:19:22.123Z"
           }.

        :keyword creator_data_item_id: The unique id that references a creator data item to be aliased.
         Default value is None.
        :paramtype creator_data_item_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response.json() == {
                    "aliasId": "str",  # Optional. The id for the alias.
                    "createdTimestamp": "2020-02-20 00:00:00",  # Optional. The created timestamp
                      for the alias.
                    "creatorDataItemId": "str",  # Optional. The id for the creator data item
                      that this alias references (could be null if the alias has not been assigned).
                    "lastUpdatedTimestamp": "2020-02-20 00:00:00"  # Optional. The timestamp of
                      the last time the alias was assigned.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_alias_create_request(
            api_version=api_version,
            client_id=self._config.client_id,
            creator_data_item_id=creator_data_item_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Access-Control-Expose-Headers']=self._deserialize('str', response.headers.get('Access-Control-Expose-Headers'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)



    @distributed_trace
    def list(
        self,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a list of all previously successfully created aliases.

        Submit List Request
        ^^^^^^^^^^^^^^^^^^^

        To list all your aliases, you will issue a ``GET`` request with no additional parameters.

        List Data Response
        ^^^^^^^^^^^^^^^^^^

        The List API returns the complete list of all aliases in ``json`` format. The response contains
        the following details for each alias resource:

        ..

           createdTimestamp - The timestamp that the alias was created. Format yyyy-MM-ddTHH:mm:ss.sssZ
           aliasId - The id for the alias.
           creatorDataItemId - The id for the creator data item that this alias references (could be
        null if the alias has not been assigned).
           lastUpdatedTimestamp - The last time the alias was assigned to a resource. Format
        yyyy-MM-ddTHH:mm:ss.sssZ


        A sample response returning 2 alias resources:

        .. code-block:: json

           {
             "aliases": [
               {
                 "createdTimestamp": "2020-02-13T21:19:11.123Z",
                 "aliasId": "a8a4b8bb-ecf4-fb27-a618-f41721552766",
                 "creatorDataItemId": "e89aebb9-70a3-8fe1-32bb-1fbd0c725f14",
                 "lastUpdatedTimestamp": "2020-02-13T21:19:22.123Z"
               },
               {
                 "createdTimestamp": "2020-02-18T19:53:33.123Z",
                 "aliasId": "1856dbfc-7a66-ee5a-bf8d-51dbfe1906f6",
                 "creatorDataItemId": null,
                 "lastUpdatedTimestamp": "2020-02-18T19:53:33.123Z"
               }
             ]
           }.

        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "aliases": [
                        {
                            "aliasId": "str",  # Optional. The id for the alias.
                            "createdTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              created timestamp for the alias.
                            "creatorDataItemId": "str",  # Optional. The id for the
                              creator data item that this alias references (could be null if the alias
                              has not been assigned).
                            "lastUpdatedTimestamp": "2020-02-20 00:00:00"  # Optional.
                              The timestamp of the last time the alias was assigned.
                        }
                    ],
                    "nextLink": "str"  # Optional. If present, the location of the next page of
                      data.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_alias_list_request(
                    api_version=api_version,
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_alias_list_request(
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["aliases"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )


    @distributed_trace_async
    async def assign(
        self,
        alias_id: str,
        *,
        creator_data_item_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to assign an alias to reference a resource.

        Submit Assign Request
        ^^^^^^^^^^^^^^^^^^^^^

        To assign your alias to a resource, you will use a ``PUT`` request with the ``aliasId`` in the
        path and the ``creatorDataItemId`` passed as a query parameter.

        Assign Alias Response
        ^^^^^^^^^^^^^^^^^^^^^

        The Assign API returns a HTTP ``200 OK`` response with the updated alias resource in the body,
        if the alias was assigned successfully. A sample of the assign response is

        .. code-block:: json

           {
             "createdTimestamp": "2020-02-13T21:19:11.123Z",
             "aliasId": "a8a4b8bb-ecf4-fb27-a618-f41721552766",
             "creatorDataItemId": "e89aebb9-70a3-8fe1-32bb-1fbd0c725f14",
             "lastUpdatedTimestamp": "2020-02-13T21:19:22.123Z"
           }.

        :param alias_id: The unique id that references an existing alias.
        :type alias_id: str
        :keyword creator_data_item_id: The unique id that references a creator data item to be aliased.
        :paramtype creator_data_item_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "aliasId": "str",  # Optional. The id for the alias.
                    "createdTimestamp": "2020-02-20 00:00:00",  # Optional. The created timestamp
                      for the alias.
                    "creatorDataItemId": "str",  # Optional. The id for the creator data item
                      that this alias references (could be null if the alias has not been assigned).
                    "lastUpdatedTimestamp": "2020-02-20 00:00:00"  # Optional. The timestamp of
                      the last time the alias was assigned.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_alias_assign_request(
            alias_id=alias_id,
            api_version=api_version,
            creator_data_item_id=creator_data_item_id,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        alias_id: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to delete a previously created alias. You can also use this API to
        delete old/unused aliases to create space for new content.This API does not delete the
        references resource, only the alias referencing the resource.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your alias you will issue a ``DELETE`` request where the path will contain the
        ``aliasId`` of the alias to delete.

        Delete Alias Response
        ^^^^^^^^^^^^^^^^^^^^^

        The Delete API returns a HTTP ``204 No Content`` response with an empty body, if the alias was
        deleted successfully.

        :param alias_id: The unique id that references an existing alias.
        :type alias_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_alias_delete_request(
            alias_id=alias_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get(
        self,
        alias_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch the details of a previously created alias.

        Submit Get Details Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^

        To get the details of your alias, you will issue a ``GET`` request with the ``aliasId`` in the
        path.

        Get Details Response
        ^^^^^^^^^^^^^^^^^^^^

        The Get Details API returns the previously created alias in ``json`` format. The response
        contains the following details for the alias resource:

        ..

           createdTimestamp - The timestamp that the alias was created.
           aliasId - The id for the alias.
           creatorDataItemId - The id for the creator data item that this alias references (could be
        null if the alias has not been assigned).
           lastUpdatedTimestamp - The last time the alias was assigned to a resource.


        Here's a sample response:

        .. code-block:: json

           {
             "createdTimestamp": "2020-02-13T21:19:11.123Z",
             "aliasId": "a8a4b8bb-ecf4-fb27-a618-f41721552766",
             "creatorDataItemId": "e89aebb9-70a3-8fe1-32bb-1fbd0c725f14",
             "lastUpdatedTimestamp": "2020-02-13T21:19:22.123Z"
           }.

        :param alias_id: The unique id that references an existing alias.
        :type alias_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "aliasId": "str",  # Optional. The id for the alias.
                    "createdTimestamp": "2020-02-20 00:00:00",  # Optional. The created timestamp
                      for the alias.
                    "creatorDataItemId": "str",  # Optional. The id for the creator data item
                      that this alias references (could be null if the alias has not been assigned).
                    "lastUpdatedTimestamp": "2020-02-20 00:00:00"  # Optional. The timestamp of
                      the last time the alias was assigned.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_alias_get_request(
            alias_id=alias_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class DataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`data` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    async def _upload_initial(
        self,
        upload_content: Union[IO, Any],
        *,
        data_format: str,
        description: Optional[str] = None,
        content_type: Optional[str] = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = None
        _content = None
        content_type = content_type or ""
        if content_type.split(";")[0] in ['application/json']:
            _json = upload_content
        elif content_type.split(";")[0] in ['application/octet-stream']:
            _content = upload_content
        else:
            raise ValueError(
                "The content_type '{}' is not one of the allowed values: "
                "['application/octet-stream', 'application/json']".format(content_type)
            )

        request = build_data_upload_request_initial(
            api_version=api_version,
            content_type=content_type,
            data_format=data_format,
            json=_json,
            content=_content,
            client_id=self._config.client_id,
            description=description,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))
            

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized



    @distributed_trace_async
    async def begin_upload(
        self,
        upload_content: Union[IO, Any],
        *,
        data_format: str,
        description: Optional[str] = None,
        content_type: Optional[str] = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Data Upload API allows the caller to upload data content to the Azure Maps service.
        You can use this API in a scenario like uploading a collection of Geofences in ``GeoJSON``
        format, for use in our `Azure Maps Geofencing Service
        <https://docs.microsoft.com/rest/api/maps/spatial>`_.

        ..

           [!Important]
           By using this feature, you agree to the preview legal terms. See the `Preview Supplemental
        Terms <https://azure.microsoft.com/en-us/support/legal/preview-supplemental-terms/>`_ for
        additional details.

           Submit Upload Request
           ---------------------


        To upload your content you will use a ``POST`` request. The request body will contain the data
        to upload. The
        ``dataFormat`` query parameter will contain the format for the data, the ``dataSharingLevel``
        query parameter
        can contain the sharing level for the data. The ``Content-Type`` header will be set to the
        content type of the
        data.

        For example, to upload a collection of geofences  in ``GeoJSON`` format, set the request body
        to the geofence
        content. Set the ``dataFormat`` query parameter to *geojson*\ , and set the ``Content-Type``
        header to either one
        of the following media types:


        * ``application/json``
        * ``application/vnd.geo+json``
        * ``application/octet-stream``

        Here's a sample request body for uploading a simple Geofence represented as a circle geometry
        using a center
        point and a radius. The sample below is in ``GeoJSON``\ :

        .. code-block:: json

           {
               "type": "FeatureCollection",
               "features": [{
                   "type": "Feature",
                   "geometry": {
                       "type": "Point",
                       "coordinates": [-122.126986, 47.639754]
                   },
                   "properties": {
                       "geometryId": "001",
                       "radius": 500
                   }
               }]
           }

        The Data Upload API performs a
        `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        Data Upload Limits
        ------------------

        Please, be aware that currently every Azure Maps account has a `data storage limit
        <https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits>`_.
        Once the storage limit is reached, all the new upload API calls will return a ``409 Conflict``
        http error response.
        You can always use the `Data Delete API
        <https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview>`_ to
        delete old/unused content and create space for new uploads.

        :param upload_content: The content to upload.
        :type upload_content: IO or any
        :keyword data_format: Data format of the content being uploaded. Known values are: "geojson",
         "zip", and "dwgzippackage".
        :paramtype data_format: str
        :keyword description: The description to be given to the upload. Default value is None.
        :paramtype description: str
        :keyword content_type: Media type of the body sent to the API. Known values are:
         "application/octet-stream" or "application/json". Default value is "application/json".
        :paramtype content_type: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._upload_initial(  # type: ignore
                upload_content=upload_content,
                data_format=data_format,
                description=description,
                content_type=content_type,
                api_version=api_version,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized


        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncLROBasePolling(
                lro_delay,
                lro_options={'final-state-via': 'location'},
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: AsyncPollingMethod
        elif polling is False: polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace_async
    async def list(
        self,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        This API allows the caller to fetch a list of all content uploaded previously using the `Data
        Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview>`_.

        ..

           [!Important]
           By using this feature, you agree to the preview legal terms. See the `Preview Supplemental
        Terms <https://azure.microsoft.com/en-us/support/legal/preview-supplemental-terms/>`_ for
        additional details.

           Submit List Request
           ^^^^^^^^^^^^^^^^^^^


        To list all your map data content you will issue a ``GET`` request with no additional
        parameters.

        List Data Response
        ^^^^^^^^^^^^^^^^^^

        The Data List API returns the complete list of all data in ``json`` format. The response
        contains the following details for each data resource:

        ..

           udid - The unique data id for the data resource.

           location - The location of the data resource. Execute a HTTP ``GET`` on this location to
        download the data.


        Here's a sample response returning the ``udid`` and ``location`` of 3 data resources:

        :code:`<br>`

        .. code-block:: json

           {
               "mapDataList":
               [
                   {
                       "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c",
                       "location":
        "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0",
                       "sizeInBytes": 29920,
                       "uploadStatus": "Completed"
                   },
                   {
                       "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c",
                       "location":
        "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0",
                       "sizeInBytes": 1339,
                       "uploadStatus": "Completed"
                   },
                   {
                       "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c",
                       "location":
        "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0",
                       "sizeInBytes": 1650,
                       "uploadStatus": "Pending"
                   }]
           }

        :code:`<br>`.

        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "mapDataList": [
                        {
                            "dataFormat": "str",  # Optional. Known values are:
                              "geojson", "zip", "dwgzippackage".
                            "description": "str",  # Optional. The current description.
                            "location": "str",  # Optional. The location of the data.
                              Execute a HTTP ``GET`` on this location to download the data.
                            "sizeInBytes": 0.0,  # Optional. The size of the content in
                              bytes.
                            "udid": "str",  # Optional. The unique data id for the data.
                            "uploadStatus": "str"  # Optional. The current upload status
                              of the content. Known values are: "Pending", "Completed", "Failed".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_data_list_request(
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    async def _update_initial(
        self,
        udid: str,
        update_content: Any,
        *,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = update_content

        request = build_data_update_request_initial(
            udid=udid,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            client_id=self._config.client_id,
            description=description,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))
            

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized



    @distributed_trace_async
    async def begin_update(
        self,
        udid: str,
        update_content: Any,
        *,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Data Update API allows the caller to update a previously uploaded data content.

        You can use this API in a scenario like adding or removing geofences to or from an existing
        collection of geofences.
        Geofences are uploaded using the `Data Upload API
        <https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview>`_\ , for
        use in the `Azure Maps Geofencing Service <https://docs.microsoft.com/rest/api/maps/spatial>`_.

        Please note that the Update API will *replace* and *override* the existing data content.

        ..

           [!Important]
           By using this feature, you agree to the preview legal terms. See the `Preview Supplemental
        Terms <https://azure.microsoft.com/en-us/support/legal/preview-supplemental-terms/>`_ for
        additional details.

           Submit Update Request
           ---------------------


        To update your content you will use a ``PUT`` request. The request body will contain the new
        data that will replace
        the existing data. The ``Content-Type`` header will be set to the content type of the data, and
        the path will contain
        the ``udid`` of the data to be update.

        For example, to update a collection of geofences that were previously uploaded using the Upload
        API, place the new
        geofence content in the request body. Set the ``udid`` parameter in the path to the ``udid`` of
        the data received
        previously in the upload API response. And set the ``Content-Type`` header to one of the
        following media types:


        * ``application/json``
        * ``application/vnd.geo+json``
        * ``application/octet-stream``

        Here's a sample request body for updating a simple Geofence. It's represented as a circle
        geometry using a center
        point and a radius. The sample below is in ``GeoJSON``\ :

        .. code-block:: json

           {
               "type": "FeatureCollection",
               "features": [{
                   "type": "Feature",
                   "geometry": {
                       "type": "Point",
                       "coordinates": [-122.126986, 47.639754]
                   },
                   "properties": {
                       "geometryId": "001",
                       "radius": 500
                   }
               }]
           }

        The previously uploaded geofence had a radius of 100m. The above request will update it to
        500m.

        The Data Update API performs a
        `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        Data Update Limits
        ------------------

        Please, be aware that currently every Azure Maps account has a `data storage limit
        <https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits>`_.
        Once the storage limit is reached, all the new upload API calls will return a ``409 Conflict``
        http error response.
        You can always use the `Data Delete API
        <https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview>`_ to
        delete old/unused content and create space for new uploads.

        :param udid: The unique data id for the content. The ``udid`` must have been obtained from a
         successful `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview>`_ call.
        :type udid: str
        :param update_content: The new content that will update/replace the previously uploaded
         content.
        :type update_content: any
        :keyword description: The description to be given to the upload. Default value is None.
        :paramtype description: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_initial(  # type: ignore
                udid=udid,
                update_content=update_content,
                description=description,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized


        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncLROBasePolling(
                lro_delay,
                lro_options={'final-state-via': 'location'},
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: AsyncPollingMethod
        elif polling is False: polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace_async
    async def download(
        self,
        udid: str,
        **kwargs: Any
    ) -> IO:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        This API allows the caller to download a previously uploaded data content.:code:`<br>`\
        :raw-html-m2r:`<br>`
        You can use this API in a scenario like downloading an existing collection of geofences
        uploaded previously using the `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview>`_ for use in our `Azure
        Maps Geofencing Service <https://docs.microsoft.com/en-us/rest/api/maps/spatial>`_.

        ..

           [!Important]
           By using this feature, you agree to the preview legal terms. See the `Preview Supplemental
        Terms <https://azure.microsoft.com/en-us/support/legal/preview-supplemental-terms/>`_ for
        additional details.

           Submit Download Request
           ^^^^^^^^^^^^^^^^^^^^^^^


        To download your content you will use a ``GET`` request where the path will contain the
        ``udid`` of the data to download. Optionally, you can also pass in an ``Accept`` header to
        specify a preference for the ``Content-Type`` of the data response. :code:`<br>`
        For example, to download a collection of geofences previously uploaded using the Upload API,
        set the ``udid`` parameter in the path to the ``udid`` of the data received previously in the
        upload API response and set the ``Accept`` header to either one of the following media types:


        * ``application/json``
        * ``application/vnd.geo+json``
        * ``application/octet-stream``

        Download Data Response
        ^^^^^^^^^^^^^^^^^^^^^^

        The Download API will return a HTTP ``200 OK`` response if the data resource with the passed-in
        ``udid`` is found, where the response body will contain the content of the data
        resource.:code:`<br>`
        A HTTP ``400 Bad Request`` error response will be returned if the data resource with the
        passed-in ``udid`` is not found.:code:`<br>`

        Here's a sample response body for a simple geofence represented in ``GeoJSON`` uploaded
        previously using the Upload API:
        :code:`<br>`

        .. code-block:: json

           {
               "type": "FeatureCollection",
               "features": [{
                   "type": "Feature",
                   "geometry": {
                       "type": "Point",
                       "coordinates": [-122.126986, 47.639754]
                   },
                   "properties": {
                       "geometryId": "001",
                       "radius": 500
                   }
               }]
           }.

        :param udid: The unique data id for the content. The ``udid`` must have been obtained from a
         successful `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview>`_ call.
        :type udid: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: IO
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]

        
        request = build_data_download_request(
            udid=udid,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=True,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))

        deserialized = response

        if cls:
            return cls(pipeline_response, cast(IO, deserialized), response_headers)

        return cast(IO, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        udid: str,
        **kwargs: Any
    ) -> None:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        This API allows the caller to delete a previously uploaded data content.:code:`<br>`\
        :raw-html-m2r:`<br>`
        You can use this API in a scenario like removing geofences previously uploaded using the `Data
        Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview>`_ for use in
        our `Azure Maps Geofencing Service <https://docs.microsoft.com/en-us/rest/api/maps/spatial>`_.
        You can also use this API to delete old/unused uploaded content and create space for new
        content.

        ..

           [!Important]
           By using this feature, you agree to the preview legal terms. See the `Preview Supplemental
        Terms <https://azure.microsoft.com/en-us/support/legal/preview-supplemental-terms/>`_ for
        additional details.

           Submit Delete Request
           ^^^^^^^^^^^^^^^^^^^^^


        To delete your content you will issue a ``DELETE`` request where the path will contain the
        ``udid`` of the data to delete.:code:`<br>`\ :raw-html-m2r:`<br>`
        For example, to delete a collection of geofences previously uploaded using the Upload API, set
        the ``udid`` parameter in the path to the ``udid`` of the data received previously in the
        upload API response.

        Delete Data Response
        ^^^^^^^^^^^^^^^^^^^^

        The Data Delete API returns a HTTP ``204 No Content`` response with an empty body, if the data
        resource was deleted successfully.:code:`<br>`\ :raw-html-m2r:`<br>`
        A HTTP ``400 Bad Request`` error response will be returned if the data resource with the
        passed-in ``udid`` is not found.

        :param udid: The unique data id for the content. The ``udid`` must have been obtained from a
         successful `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview>`_ call.
        :type udid: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_data_delete_request(
            udid=udid,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_operation(
        self,
        operation_id: str,
        **kwargs: Any
    ) -> JSON:
        """This path will be obtained from a call to POST /mapData.  While in progress, an http200 will be
        returned with no extra headers -  followed by an http200 with Resource-Location header once
        completed.

        ..

           [!Important]
           By using this feature, you agree to the preview legal terms. See the `Preview Supplemental
        Terms <https://azure.microsoft.com/en-us/support/legal/preview-supplemental-terms/>`_ for
        additional details.

        :param operation_id: The ID to query the status for the data upload request.
        :type operation_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "operationId": "str",  # Optional. The Id for this long-running operation.
                    "status": "str",  # Optional. The status state of the request. Known values
                      are: "NotStarted", "Running", "Failed", "Succeeded".
                    "warning": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_data_get_operation_request(
            operation_id=operation_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)


class DatasetOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`dataset` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    async def _create_initial(
        self,
        *,
        conversion_id: str,
        dataset_id: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_dataset_create_request_initial(
            api_version=api_version,
            conversion_id=conversion_id,
            client_id=self._config.client_id,
            dataset_id=dataset_id,
            description=description,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))
            

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized



    @distributed_trace_async
    async def begin_create(
        self,
        *,
        conversion_id: str,
        dataset_id: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API allows the caller to create a dataset from data that was uploaded to the Azure Maps
        Data Service and converted using the Azure Maps Conversion Service.

        You can use this API in a scenario like uploading a DWG zip package for a building, converting
        the zip package using the Azure Maps Conversion Service, and creating a dataset from the
        converted zip package. The created dataset can be used to create tilesets using the Azure Maps
        Tileset Service and can be queried via the Azure Maps WFS Service.

        Submit Create Request
        ^^^^^^^^^^^^^^^^^^^^^

        To create your dataset, you will use a ``POST`` request where the ``conversionId`` query
        parameter is an ID that represents the converted DWG zip package, the ``datasetId`` parameter
        will be the ID of a previously created dataset to append with the current dataset and,
        optionally, the ``description`` query parameter will contain a description (if description is
        not provided a default description will be given).

        The Create API is a `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        :keyword conversion_id: The unique ID used to create the dataset. The ``conversionId`` must
         have been obtained from a successful call to the Conversion Service `Convert API
         <https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert>`_ and may be provided
         with multiple query parameters with same name (if more than one is provided).
        :paramtype conversion_id: str
        :keyword dataset_id: The ID for the dataset to append with. The dataset must originate from a
         previous dataset creation call that matches the datasetId. Default value is None.
        :paramtype dataset_id: str
        :keyword description: The description to be given to the dataset. Default value is None.
        :paramtype description: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "operationId": "str",  # Optional. The Id for this long-running operation.
                    "status": "str",  # Optional. The status state of the request. Known values
                      are: "NotStarted", "Running", "Failed", "Succeeded".
                    "warning": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_initial(  # type: ignore
                conversion_id=conversion_id,
                dataset_id=dataset_id,
                description=description,
                api_version=api_version,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized


        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncLROBasePolling(
                lro_delay,
                lro_options={'final-state-via': 'location'},
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: AsyncPollingMethod
        elif polling is False: polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace
    def list(
        self,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a list of all previously successfully created datasets.

        Submit List Request
        ^^^^^^^^^^^^^^^^^^^

        To list all your datasets, you will issue a ``GET`` request with no additional parameters.

        List Data Response
        ^^^^^^^^^^^^^^^^^^

        The List API returns the complete list of all datasets in ``json`` format. The response
        contains the following fields (if they are not null or empty):

        ..

           created - The timestamp the dataset was created.
           datasetId - The id for the dataset.
           description - The description for the dataset.
           datasetSources - The source data that was used when the create request was issued.
           ontology - The source `ontology
        <https://docs.microsoft.com/en-us/azure/azure-maps/creator-facility-ontology>`_ that was used
        in the conversion service for the input data.:code:`<br/>`


        The ``datasetSources`` describes the source data that was used when the create request was
        issued and contains the following elements (if they are not null or empty):

        ..

           conversionIds - The list of ``conversionId`` (null if none were provided).
           appendDatasetId - The ``datasetId`` that was used for an append operation (null if none was
        used).
           featureCounts - The counts for each feature type in the dataset.:code:`<br/>`


        Here's a sample response returning the ``timestamp``\ , ``datasetId``\ , ``description``\ ,
        ``datasetSources``\ , and ``ontology`` of 3 dataset resources:

        .. code-block:: json

           {
             "datasets": [
               {
                 "timestamp": "2020-01-01T22:50:48.123Z",
                 "datasetId": "f6495f62-94f8-0ec2-c252-45626f82fcb2",
                 "description": "Some description or comment for the dataset.",
                 "datasetSources": {
                   "conversionIds": [
                     "15d21452-c9bb-27b6-5e79-743ca5c3205d"
                   ],      },
                 "": "facility-2.0",
                 "featureCounts": {
                   "directoryInfo": 2,
                   "category": 10,
                   "facility": 1,
                   "level": 3,
                   "unit": 183,
                   "zone": 3,
                   "verticalPenetration": 6,
                   "opening": 48,
                   "areaElement": 108
                 }
               },
               {
                 "timestamp": "2020-01-01T22:57:53.123Z",
                 "datasetId": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c",
                 "description": "Create from upload '0c1288fa-2058-4a1b-b68d-13a5f5af7d7c'.",
                 "datasetSources": {
                   "conversionIds": [
                     "0c1288fa-2058-4a1b-b68d-13a5f5af7d7c"
                   ],
                   "appendDatasetId": "46d1edb6-d29e-4786-9589-dbd4efd7a977"
                 },
                 "ontology": "facility-2.0",
                 "featureCounts": {
                   "directoryInfo": 2,
                   "category": 10,
                   "facility": 1,
                   "level": 3,
                   "unit": 183,
                   "zone": 3,
                   "verticalPenetration": 6,
                   "opening": 48,
                   "areaElement": 108
                 }
               }
             ]
           }.

        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "datasets": [
                        {
                            "created": "2020-02-20 00:00:00",  # Optional. The created
                              timestamp for the dataset.
                            "datasetId": "str",  # Optional. The id for the dataset.
                            "datasetSources": {
                                "appendDatasetId": "str",  # Optional. The dataset
                                  that was appended to to create the current dataset.
                                "conversionIds": [
                                    "str"  # Optional. The list of
                                      ``conversionId`` that were used to create the dataset.
                                ]
                            },
                            "description": "str",  # Optional. The description for the
                              dataset.
                            "featureCounts": {},  # Optional. The feature counts for the
                              dataset.
                            "ontology": "str"  # Optional. The ontology version of this
                              dataset.
                        }
                    ],
                    "nextLink": "str"  # Optional. If present, the location of the next page of
                      data.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_dataset_list_request(
                    api_version=api_version,
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_dataset_list_request(
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["datasets"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )


    @distributed_trace_async
    async def get(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a previously successfully created dataset.

        Submit Get Details Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^

        To get the details for a previously created dataset, you will issue a ``GET`` request with the
        ``datasetId`` in the path.

        Get Details Response
        ^^^^^^^^^^^^^^^^^^^^

        The Get Details API returns the details for a dataset in ``json`` format. The response contains
        the following fields (if they are not null or empty):

        ..

           created - The timestamp the dataset was created.
           datasetId - The id for the dataset.
           description - The description for the dataset.
           datasetSources - The source data that was used when the create request was issued.
           ontology - The source `ontology
        <https://docs.microsoft.com/en-us/azure/azure-maps/creator-facility-ontology>`_ that was used
        in the conversion service for the input data.:code:`<br/>`


        The ``datasetSources`` describes the source data that was used when the create request was
        issued and contains the following elements (if they are not null or empty):

        ..

           conversionIds - The list of ``conversionId`` (null if none were provided).
           appendDatasetId - The ``datasetId`` that was used for an append operation (null if none was
        used).
           featureCounts - The counts for each feature type in the dataset.:code:`<br/>`


        Here's a sample response returning the ``timestamp``\ , ``datasetId``\ , ``description``\ ,
        ``datasetSources``\ , and ``ontology`` of a dataset resource:

        .. code-block:: json

           {
              "timestamp": "2020-01-01T22:50:48.123Z",
              "datasetId": "f6495f62-94f8-0ec2-c252-45626f82fcb2",
              "description": "Some description or comment for the dataset.",
              "datasetSources": {
                "conversionIds": [
                  "15d21452-c9bb-27b6-5e79-743ca5c3205d"
                ],
              },
              "ontology": "facility-2.0",
              "featureCounts": {
                "directoryInfo": 2,
                "category": 10,
                "facility": 1,
                "level": 3,
                "unit": 183,
                "zone": 3,
                "verticalPenetration": 6,
                "opening": 48,
                "areaElement": 108
              }
            }.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp for the
                      dataset.
                    "datasetId": "str",  # Optional. The id for the dataset.
                    "datasetSources": {
                        "appendDatasetId": "str",  # Optional. The dataset that was appended
                          to to create the current dataset.
                        "conversionIds": [
                            "str"  # Optional. The list of ``conversionId`` that were
                              used to create the dataset.
                        ]
                    },
                    "description": "str",  # Optional. The description for the dataset.
                    "featureCounts": {},  # Optional. The feature counts for the dataset.
                    "ontology": "str"  # Optional. The ontology version of this dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_dataset_get_request(
            dataset_id=dataset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        You can also use this API to delete old/unused datasets to create space for new Creator
        content.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your content you will issue a ``DELETE`` request where the path will contain the
        ``datasetId`` of the dataset to delete.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_dataset_delete_request(
            dataset_id=dataset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_operation(
        self,
        operation_id: str,
        **kwargs: Any
    ) -> JSON:
        """This API allows the caller to view the current progress of a dataset operation and the path is
        obtained from a call to the Create API.

        Submit Operations Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^

        To view the current progress of a dataset operation, you will use a ``GET`` request where the
        ``operationId`` given the path is the ID that represents the operation.

        Operation Response
        ^^^^^^^^^^^^^^^^^^

        While in progress, a ``200-OK`` http status code will be returned with no extra headers. If the
        operation succeeds, a ``200-OK`` http status code with Resource-Location header will be
        returned.

        :param operation_id: The ID to query the status for the dataset create/import request.
        :type operation_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "operationId": "str",  # Optional. The Id for this long-running operation.
                    "status": "str",  # Optional. The status state of the request. Known values
                      are: "NotStarted", "Running", "Failed", "Succeeded".
                    "warning": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_dataset_get_operation_request(
            operation_id=operation_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)


class ConversionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`conversion` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    async def _convert_initial(
        self,
        *,
        udid: str,
        output_ontology: str = "facility-2.0",
        description: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_conversion_convert_request_initial(
            api_version=api_version,
            udid=udid,
            client_id=self._config.client_id,
            output_ontology=output_ontology,
            description=description,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))
            

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized



    @distributed_trace_async
    async def begin_convert(
        self,
        *,
        udid: str,
        output_ontology: str = "facility-2.0",
        description: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        The Conversion API lets the caller import a set of DWG design files as a zipped `Drawing
        Package <https://aka.ms/am-drawing-package>`_ into Azure Maps. The `Drawing Package
        <https://aka.ms/am-drawing-package>`_ should first be uploaded using the `Azure Maps Data
        Service <https://docs.microsoft.com/rest/api/maps/data>`_. Once uploaded, use the ``udid``
        returned by the `Data Upload API
        <https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview>`_ to call this Conversion
        API.

        Convert DWG package
        -------------------

        The Conversion API performs a `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        Debug DWG package issues
        ------------------------

        During the Conversion process, if there are any issues with the DWG package `errors and
        warnings <https://aka.ms/am-conversion-errors>`_ are provided in the response along with a
        *diagnostic package* to visualize and diagnose these issues. In case any issues are encountered
        with your DWG package, the Conversion operation status process as detailed `here
        <https://aka.ms/am-creator-lrt-v2>`_ returns the location of the *diagnostic package* that can
        be downloaded by the caller to help them visualize and diagnose these issues. The *diagnostic
        package* location can be found in the properties section of the conversion operation status
        response and looks like the following:

        .. code-block:: json

           {
               "properties": {
                   "diagnosticPackageLocation":
        "https://us.atlas.microsoft.com/mapdata/{DiagnosticPackageId}?api-version=1.0"
               }
           }

        The *diagnostic package* can be downloaded by executing a ``HTTP GET`` request on the
        ``diagnosticPackageLocation``.
        For more details on how to use the tool to visualize and diagnose all the errors and warnings
        see `Drawing Error Visualizer <https://aka.ms/am-drawing-errors-visualizer>`_. :code:`<br>`

        A conversion operation will be marked as *success* if there are zero or more warnings but will
        be marked as *failed* if any errors are encountered.

        :keyword udid: The unique data id for the content. The ``udid`` must have been obtained from a
         successful `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview>`_ call.
        :paramtype udid: str
        :keyword output_ontology: Output ontology version. "facility-2.0" is the only supported value
         at this time. Please refer to this `article
         <https://docs.microsoft.com/en-us/azure/azure-maps/creator-facility-ontology>`_ for more
         information about Azure Maps Creator ontologies. "facility-2.0" Default value is
         "facility-2.0".
        :paramtype output_ontology: str
        :keyword description: User provided description of the content being converted. Default value
         is None.
        :paramtype description: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "operationId": "str",  # Optional. The Id for this long-running operation.
                    "status": "str",  # Optional. The status state of the request. Known values
                      are: "NotStarted", "Running", "Failed", "Succeeded".
                    "warning": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._convert_initial(  # type: ignore
                udid=udid,
                output_ontology=output_ontology,
                description=description,
                api_version=api_version,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized


        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncLROBasePolling(
                lro_delay,
                lro_options={'final-state-via': 'location'},
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: AsyncPollingMethod
        elif polling is False: polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace
    def list(
        self,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a list of all successful data conversions submitted
        previously using the `Conversion API
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert>`_.

        Submit List Request
        ^^^^^^^^^^^^^^^^^^^

        To list all successful conversions you will issue a ``GET`` request with no additional
        parameters.

        List Data Response
        ^^^^^^^^^^^^^^^^^^

        The Conversion List API returns the complete list of all conversion details in ``json``
        format.:code:`<br>`

        Here is a sample response returning the details of two successful conversion requests:

        :code:`<br>`

        .. code-block:: json

           {
               "conversions":
               [
                   {
                       "conversionId": "54398242-ea6c-1f31-4fa6-79b1ae0fc24d",
                       "udid": "31838736-8b84-11ea-bc55-0242ac130003",
                       "created": "5/19/2020 9:00:00 AM +00:00",
                       "description": "User provided description.",
                       "featureCounts": {
                           "DIR": 1,
                           "LVL": 3,
                           "FCL": 1,
                           "UNIT": 150,
                           "CTG": 8,
                           "AEL": 0,
                           "OPN": 10
                       }
                   },
                   {
                       "conversionId": "2acf7d32-8b84-11ea-bc55-0242ac130003",
                       "udid": "1214bc58-8b84-11ea-bc55-0242ac1300039",
                       "created": "5/19/2020 9:00:00 AM +00:00",
                       "description": "User provided description.",
                       "featureCounts": {
                           "DIR": 1,
                           "LVL": 3,
                           "FCL": 1,
                           "UNIT": 150,
                           "CTG": 8,
                           "AEL": 0,
                           "OPN": 10
                       }
                   }
               ]
           }

        :code:`<br>`.

        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "conversions": [
                        {
                            "conversionId": "str",  # Optional. A unique id that
                              represents the artifact of a *successfully* completed conversion process.
                            "created": "str",  # Optional. The date and time of this
                              conversion.
                            "description": "str",  # Optional. User provided description
                              of the content being converted.
                            "featureCounts": {
                                "str": 0.0  # Optional. A summary of feature counts
                                  in this conversion.
                            },
                            "ontology": "str",  # Optional. The ontology version of this
                              dataset.
                            "udid": "str"  # Optional. The unique id of the content
                              provided to create this conversion.
                        }
                    ],
                    "nextLink": "str"  # Optional. If present, the location of the next page of
                      data.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_conversion_list_request(
                    api_version=api_version,
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_conversion_list_request(
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["conversions"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )


    @distributed_trace_async
    async def get(
        self,
        conversion_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a successful data conversion submitted previously using the
        `Conversion API <https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert>`_.

        :param conversion_id: The conversion id for the content. The ``conversionId`` must have been
         obtained from a successful `Conversion API
         <https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert>`_ call.
        :type conversion_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "conversionId": "str",  # Optional. A unique id that represents the artifact
                      of a *successfully* completed conversion process.
                    "created": "str",  # Optional. The date and time of this conversion.
                    "description": "str",  # Optional. User provided description of the content
                      being converted.
                    "featureCounts": {
                        "str": 0.0  # Optional. A summary of feature counts in this
                          conversion.
                    },
                    "ontology": "str",  # Optional. The ontology version of this dataset.
                    "udid": "str"  # Optional. The unique id of the content provided to create
                      this conversion.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_conversion_get_request(
            conversion_id=conversion_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        conversion_id: str,
        **kwargs: Any
    ) -> None:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to delete any data conversions created previously using the
        `Conversion API <https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert>`_.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your conversion data you will issue a ``DELETE`` request where the path will contain
        the ``conversionId`` of the data to delete.

        Conversion Delete Response
        ^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Conversion Delete API returns a HTTP ``204 No Content`` response with an empty body, if the
        converted data resources were deleted successfully.:code:`<br>`\ :raw-html-m2r:`<br>`
        A HTTP ``400 Bad Request`` error response will be returned if no resource associated with the
        passed-in ``conversionId`` is found.

        :param conversion_id: The conversion id for the content. The ``conversionId`` must have been
         obtained from a successful `Conversion API
         <https://docs.microsoft.com/en-us/rest/api/maps/v2/conversion/convert>`_ call.
        :type conversion_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_conversion_delete_request(
            conversion_id=conversion_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_operation(
        self,
        operation_id: str,
        **kwargs: Any
    ) -> JSON:
        """This path will be obtained from a call to POST /conversions.  While in progress, an http200
        will be returned with no extra headers -  followed by an http200 with Resource-Location header
        once successfully completed.

        :param operation_id: The ID to query the status for the Conversion create/import request.
        :type operation_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "operationId": "str",  # Optional. The Id for this long-running operation.
                    "status": "str",  # Optional. The status state of the request. Known values
                      are: "NotStarted", "Running", "Failed", "Succeeded".
                    "warning": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_conversion_get_operation_request(
            operation_id=operation_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)


class FeatureStateOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`feature_state` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def create_stateset(
        self,
        style_rules: JSON,
        *,
        dataset_id: str,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This POST API allows the user to create a new Stateset and define stateset style using request
        body.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. The Feature State API is part of Creator.

        The Feature State service allows the user to update the states of a feature and query them to
        be used in other services. The dynamic properties of a feature that don't belong to the dataset
        are referred to as *states* here.

        This Feature State service pivot on the Stateset. Like Tileset, Stateset encapsulates the
        storage mechanism for feature states for a dataset.

        Once the stateset is created, users can use that statesetId to post feature state updates and
        retrieve the current feature states. A feature can have only one state at a given point in
        time.

        Feature state is defined by the key name, value and the timestamp. When a feature state update
        is posted to Azure Maps, the state value gets updated only if the provided states timestamp is
        later than the stored timestamp.

        Azure Maps MapControl provides a way to use these feature states to style the features. Please
        refer to the `State Tile documentation
        <https://docs.microsoft.com/en-us/rest/api/maps/render/get-map-state-tile-preview>`_ for more
        information.

        :param style_rules: The stateset style JSON data.
        :type style_rules: JSON
        :keyword dataset_id: The datasetId must have been obtained from a successful `Dataset Create
         API <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_ call.
        :paramtype dataset_id: str
        :keyword description: Description for the stateset. Max length allowed is 1000. Default value
         is None.
        :paramtype description: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                style_rules = {
                    "styles": [
                        {
                            "keyName": "str",  # Required. Stateset style key name. Key
                              names are random strings but they should be unique inside style array.
                            type: type
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "statesetId": "str"  # Optional. The ID for the new stateset created.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = style_rules

        request = build_feature_state_create_stateset_request(
            api_version=api_version,
            content_type=content_type,
            dataset_id=dataset_id,
            json=_json,
            client_id=self._config.client_id,
            description=description,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_statesets(
        self,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API allows the caller to fetch a list of all previously successfully created statesets.

        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. If present, the location of the next page of
                      data.
                    "statesets": [
                        {
                            "datasetIds": [
                                "str"  # Optional. Dataset ID associated with the
                                  stateset.
                            ],
                            "description": "str",  # Optional. Description associated
                              with the stateset.
                            "statesetId": "str",  # Optional. The stateset ID of this
                              stateset.
                            "statesetStyle": {
                                "styles": [
                                    {
                                        "keyName": "str",  # Required.
                                          Stateset style key name. Key names are random strings but
                                          they should be unique inside style array.
                                        type: type
                                    }
                                ]
                            }
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_feature_state_list_statesets_request(
                    api_version=api_version,
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_feature_state_list_statesets_request(
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["statesets"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )


    @distributed_trace_async
    async def update_stateset(  # pylint: disable=inconsistent-return-statements
        self,
        stateset_id: str,
        style_rules: JSON,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This PUT API allows the user to update the stateset style rules.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param style_rules: The stateset style JSON data. Only style rules are allowed to be updated,
         update on keyname and type is not allowed.
        :type style_rules: JSON
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                style_rules = {
                    "styles": [
                        {
                            "keyName": "str",  # Required. Stateset style key name. Key
                              names are random strings but they should be unique inside style array.
                            type: type
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = style_rules

        request = build_feature_state_update_stateset_request(
            stateset_id=stateset_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def delete_stateset(  # pylint: disable=inconsistent-return-statements
        self,
        stateset_id: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This DELETE API allows the user to delete the stateset and the associated data.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_feature_state_delete_stateset_request(
            stateset_id=stateset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_stateset(
        self,
        stateset_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This GET API allows the user to get the stateset Information.

        The stateset Information includes the datasetId associated to the stateset, and the styles of
        that stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "datasetIds": [
                        "str"  # Optional. Dataset ID associated with the stateset.
                    ],
                    "description": "str",  # Optional. Description associated with the stateset.
                    "statesetStyle": {
                        "styles": [
                            {
                                "keyName": "str",  # Required. Stateset style key
                                  name. Key names are random strings but they should be unique inside
                                  style array.
                                type: type
                            }
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_feature_state_get_stateset_request(
            stateset_id=stateset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def update_states(  # pylint: disable=inconsistent-return-statements
        self,
        stateset_id: str,
        feature_id: str,
        feature_states: JSON,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This PUT API allows the user to update the state of the given feature in the given stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given dataset. If the featureId is not present in
         the dataset, Bad Request response will be returned.
        :type feature_id: str
        :param feature_states: The feature state JSON data. A feature can have only one state at a
         given point in time. The specified state keyname must have been defined during the stateset
         creation.
        :type feature_states: JSON
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                feature_states = {
                    "states": [
                        {
                            "eventTimestamp": "str",  # Optional. Valid Timestamp when
                              the feature state was captured.
                            "keyName": "str",  # Optional. Feature state Keyname. Maximum
                              length allowed is 1000.
                            "value": "str"  # Optional. Value for the feature state. Type
                              should comply with the style definition attached to the featurestate.
                              Maximum length allowed for string type is 1024.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = feature_states

        request = build_feature_state_update_states_request(
            stateset_id=stateset_id,
            feature_id=feature_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def delete_state(  # pylint: disable=inconsistent-return-statements
        self,
        stateset_id: str,
        feature_id: str,
        *,
        key_name: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API deletes the state information identified by the StateKeyName parameter for the
        feature identified by the FeatureId parameter in the the stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given stateset. If no state was set for the
         featureId in the stateset earlier, Bad Request response will be returned.
        :type feature_id: str
        :keyword key_name: The Name of the state to be deleted.
        :paramtype key_name: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_feature_state_delete_state_request(
            stateset_id=stateset_id,
            feature_id=feature_id,
            api_version=api_version,
            key_name=key_name,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def list_states(
        self,
        stateset_id: str,
        feature_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API returns the current state information associated with the given feature in the given
        stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given stateset. If no state was set for the
         featureId in the stateset earlier, Bad Request response will be returned.
        :type feature_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "states": [
                        {
                            "eventTimestamp": "str",  # Optional. Valid Timestamp when
                              the feature state was captured.
                            "keyName": "str",  # Optional. Feature state Keyname. Maximum
                              length allowed is 1000.
                            "value": "str"  # Optional. Value for the feature state. Type
                              should comply with the style definition attached to the featurestate.
                              Maximum length allowed for string type is 1024.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_feature_state_list_states_request(
            stateset_id=stateset_id,
            feature_id=feature_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SpatialOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`spatial` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def get_geofence(
        self,
        format: str = "json",
        *,
        device_id: str,
        udid: str,
        latitude: float,
        longitude: float,
        altitude: Optional[float] = None,
        user_time: Optional[datetime.datetime] = None,
        search_buffer_in_meters: Optional[float] = None,
        is_async: Optional[bool] = None,
        mode: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """**Search Geofence Get API**

        **Applies to:** S1 Pricing tier.

        The Geofence Get API allows you to retrieve the proximity of a coordinate to a
        geofence that has been uploaded to the Data service. You can use the
        `Data Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ to
        upload
        a geofence or set of fences. See `Geofencing GeoJSON data
        <https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson>`_
        for more details on the geofence data format. To query the proximity of a coordinate, you
        supply the location of the object you are tracking as well
        as the ID for the fence or set of fences, and the response will contain information about
        the distance from the outer edge of the geofence. A negative value signifies that the
        coordinate is inside of the fence while a positive value means that it is outside of the
        fence.:code:`<br>`:code:`<br>`This API can be used for a variety of scenarios that include
        things like asset
        tracking, fleet management, or setting up alerts for moving objects.

        The API supports `integration with Event Grid
        <https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration>`_. The isAsync
        parameter is used to enable integration with Event Grid (disabled by default).
        To test this API, you can upload the sample data from Post Geofence API examples(Request Body)
        via Data Upload API and replace the [udid] from the sample request below with the udid returned
        by Data Upload API.

        Geofencing InnerError code
        ^^^^^^^^^^^^^^^^^^^^^^^^^^

        In geofencing response error contract, ``innererror`` is  an object containing service specific
        information about the error. ``code`` is a property in ``innererror`` which can map to a
        specific geofencing error type. The table belows shows the code mapping between all the known
        client error type to the corresponding geofencing error ``message``.

        .. list-table::
           :header-rows: 1

           * - innererror.code
             - error.message
           * - NullDeviceId
             - Device Id should not be null.
           * - NullUdid
             - Udid should not be null.
           * - UdidWrongFormat
             - Udid should be acquired from user data ingestion API.
           * - InvalidUserTime
             - Usertime is invalid.
           * - InvalidSearchBuffer
             - Searchbuffer is invalid.
           * - InvalidSearchRange
             - The value range of searchbuffer should be from 0 to 500 meters.
           * - InvalidLatLon
             - Lat and/or lon parameters are invalid.
           * - InvalidIsAsyncValue
             - The IsAsync parameter is invalid.
           * - InvalidModeValue
             - The mode parameter invalid.
           * - InvalidJson
             - Geofencing data is not a valid json file.
           * - NotSupportedGeoJson
             - Geofencing data can't be read as a Feature or FeatureCollections.
           * - InvalidGeoJson
             - Geofencing data is invalid.
           * - NoUserDataWithAccountOrSubscription
             - Can't find user geofencing data with provided account-id and/or subscription-id.
           * - NoUserDataWithUdid
             - Can't find user geofencing data with provided udid.

        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword device_id: ID of the device.
        :paramtype device_id: str
        :keyword udid: The unique id returned from `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ after uploading a valid
         GeoJSON FeatureCollection object. Please refer to `RFC 7946
         <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details. All the feature's  properties
         should contain ``geometryId``\ , which is used for identifying the geometry and is
         case-sensitive.
        :paramtype udid: str
        :keyword latitude: The latitude of the location being passed.  Example: 48.36.
        :paramtype latitude: float
        :keyword longitude: The longitude of the location being passed.  Example: -124.63.
        :paramtype longitude: float
        :keyword altitude: The sea level in meter of the location being passed. If this parameter is
         presented, 2D extrusion is used. Example: 200. Default value is None.
        :paramtype altitude: float
        :keyword user_time: The user request time. If not presented in the request, the default value
         is DateTime.Now.
        :paramtype user_time: ~datetime.datetime
        :keyword search_buffer_in_meters: The radius of the buffer around the geofence in meters that
         defines how far to search inside and outside the border of the fence against the coordinate
         that was provided when calculating the result.  The minimum value is 0, and the maximum is 500.
         The default value is 50.
        :paramtype search_buffer_in_meters: float
        :keyword is_async: If true, the request will use async event mechanism; if false, the request
         will be synchronized and do not trigger any event. The default value is false.
        :paramtype is_async: bool
        :keyword mode: Mode of the geofencing async event mechanism. Known values are: "All" or
         "EnterAndExit". Default value is None.
        :paramtype mode: str
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "expiredGeofenceGeometryId": [
                        "str"  # Optional. Lists of the geometry ID of the geofence which is
                          expired relative to the user time in the request.
                    ],
                    "geometries": [
                        {
                            "deviceId": "str",  # Optional. ID of the device.
                            "distance": 0.0,  # Optional. Distance from the coordinate to
                              the closest border of the geofence (in meters except when special values
                              -999/999 are used). Positive means the  coordinate is outside of the
                              geofence. If the coordinate is outside of the geofence, but more than the
                              value of searchBuffer away from the closest geofence border, then the
                              value is 999. Negative means the coordinate is inside of the geofence. If
                              the coordinate is inside the polygon, but more than the value of
                              searchBuffer away from the closest geofencing border, then the value is
                              -999. A value of 999 means that there is great confidence the coordinate
                              is well outside the geofence. A value of -999 means that there is great
                              confidence the coordinate is well within the geofence.
                            "geometryId": "str",  # Optional. The unique id identifies a
                              geometry.
                            "nearestLat": 0.0,  # Optional. Latitude of the nearest point
                              of the geometry.
                            "nearestLon": 0.0,  # Optional. Longitude of the nearest
                              point of the geometry.
                            "nearestZ": 0.0,  # Optional. Sea level in meter of the
                              nearest point on the 2D extrusion geometry. This will only be presented
                              in response when value is provided for 'zInMeter' in the request.
                            "udId": "str"  # Optional. The unique id returned from `Data
                              Upload API
                              <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_
                              after uploading a valid GeoJSON FeatureCollection object. Please refer to
                              `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for
                              details. All the feature's properties should  contain ``geometryId``"" ,
                              which is used for identifying the geometry and is case-sensitive.
                        }
                    ],
                    "invalidPeriodGeofenceGeometryId": [
                        "str"  # Optional. Lists of the geometry ID of the geofence which is
                          in invalid period relative to the user time in the request.
                    ],
                    "isEventPublished": bool  # Optional. True if at least one event is published
                      to the Azure Maps event subscriber, false if no event is published to the Azure
                      Maps event subscriber. This will only be presented in response when 'isAsync'
                      query parameter is set to true.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_spatial_get_geofence_request(
            api_version=api_version,
            format=format,
            device_id=device_id,
            udid=udid,
            latitude=latitude,
            longitude=longitude,
            client_id=self._config.client_id,
            altitude=altitude,
            user_time=user_time,
            search_buffer_in_meters=search_buffer_in_meters,
            is_async=is_async,
            mode=mode,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['X-Correlation-id']=self._deserialize('str', response.headers.get('X-Correlation-id'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def post_geofence(
        self,
        search_geofence_request_body: JSON,
        format: str = "json",
        *,
        device_id: str,
        latitude: float,
        longitude: float,
        altitude: Optional[float] = None,
        user_time: Optional[datetime.datetime] = None,
        search_buffer: Optional[float] = None,
        is_async: Optional[bool] = None,
        mode: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """**Search Geofence Post API**
        **Applies to:** S1 Pricing tier.
        The Geofence Post API allows you to retrieve the proximity of a coordinate to a  provided
        geofence or set of fences. With POST call, you do not have to upload the fence data in advance,
        instead you supply the location of the object you are tracking in query parameters as well as
        the fence or set of fences data in post request body. See `Geofencing GeoJSON data
        <https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson>`_ for more details on the
        geofence data format. The response will contain information about the distance from the outer
        edge of the geofence. A negative value signifies that the  coordinate is inside of the fence
        while a positive value means that it is outside of the fence.:code:`<br>`:code:`<br>`This API
        can be used for a variety of scenarios that include things like asset  tracking, fleet
        management, or setting up alerts for moving objects.

        The API supports `integration with Event Grid
        <https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration>`_.  The isAsync
        parameter is used to enable integration with Event Grid (disabled by default).

        :param search_geofence_request_body: The geofencing GeoJSON data.
        :type search_geofence_request_body: JSON
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword device_id: ID of the device.
        :paramtype device_id: str
        :keyword latitude: The latitude of the location being passed.  Example: 48.36.
        :paramtype latitude: float
        :keyword longitude: The longitude of the location being passed.  Example: -124.63.
        :paramtype longitude: float
        :keyword altitude: The sea level in meter of the location being passed. If this parameter is
         presented, 2D extrusion geofencing is applied. Example: 200. Default value is None.
        :paramtype altitude: float
        :keyword user_time: The user request time. If not presented in the request, the default value
         is DateTime.UtcNow.
        :paramtype user_time: ~datetime.datetime
        :keyword search_buffer: The radius of the buffer around the geofence in meters that defines how
         far to search inside and outside the border of the fence against the coordinate that was
         provided when calculating the result.  The minimum value is 0, and the maximum is 500.  The
         default value is 50.
        :paramtype search_buffer: float
        :keyword is_async: If true, the request will use async event mechanism; if false, the request
         will be synchronized and do not trigger any event. The default value is false.
        :paramtype is_async: bool
        :keyword mode: Mode of the geofencing async event mechanism. Known values are: "All" or
         "EnterAndExit". Default value is None.
        :paramtype mode: str
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                search_geofence_request_body = {
                    "features": [
                        {
                            "featureType": "str",  # Optional. The type of the feature.
                              The value depends on the data model the current feature is part of. Some
                              data models may have an empty value.
                            "geometry": {
                                type: GeoJsonGeometry
                            },
                            "id": "str",  # Optional. Identifier for the feature.
                            "properties": {},  # Optional. Properties can contain any
                              additional metadata about the ``Feature``. Value can be any JSON object
                              or a JSON null value.
                            type: Feature
                        }
                    ],
                    type: FeatureCollection
                }

                # response body for status code(s): 200
                response.json() == {
                    "expiredGeofenceGeometryId": [
                        "str"  # Optional. Lists of the geometry ID of the geofence which is
                          expired relative to the user time in the request.
                    ],
                    "geometries": [
                        {
                            "deviceId": "str",  # Optional. ID of the device.
                            "distance": 0.0,  # Optional. Distance from the coordinate to
                              the closest border of the geofence (in meters except when special values
                              -999/999 are used). Positive means the  coordinate is outside of the
                              geofence. If the coordinate is outside of the geofence, but more than the
                              value of searchBuffer away from the closest geofence border, then the
                              value is 999. Negative means the coordinate is inside of the geofence. If
                              the coordinate is inside the polygon, but more than the value of
                              searchBuffer away from the closest geofencing border, then the value is
                              -999. A value of 999 means that there is great confidence the coordinate
                              is well outside the geofence. A value of -999 means that there is great
                              confidence the coordinate is well within the geofence.
                            "geometryId": "str",  # Optional. The unique id identifies a
                              geometry.
                            "nearestLat": 0.0,  # Optional. Latitude of the nearest point
                              of the geometry.
                            "nearestLon": 0.0,  # Optional. Longitude of the nearest
                              point of the geometry.
                            "nearestZ": 0.0,  # Optional. Sea level in meter of the
                              nearest point on the 2D extrusion geometry. This will only be presented
                              in response when value is provided for 'zInMeter' in the request.
                            "udId": "str"  # Optional. The unique id returned from `Data
                              Upload API
                              <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_
                              after uploading a valid GeoJSON FeatureCollection object. Please refer to
                              `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for
                              details. All the feature's properties should  contain ``geometryId``"" ,
                              which is used for identifying the geometry and is case-sensitive.
                        }
                    ],
                    "invalidPeriodGeofenceGeometryId": [
                        "str"  # Optional. Lists of the geometry ID of the geofence which is
                          in invalid period relative to the user time in the request.
                    ],
                    "isEventPublished": bool  # Optional. True if at least one event is published
                      to the Azure Maps event subscriber, false if no event is published to the Azure
                      Maps event subscriber. This will only be presented in response when 'isAsync'
                      query parameter is set to true.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = search_geofence_request_body

        request = build_spatial_post_geofence_request(
            api_version=api_version,
            format=format,
            content_type=content_type,
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            json=_json,
            client_id=self._config.client_id,
            altitude=altitude,
            user_time=user_time,
            search_buffer=search_buffer,
            is_async=is_async,
            mode=mode,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['X-Correlation-id']=self._deserialize('str', response.headers.get('X-Correlation-id'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def post_buffer(
        self,
        buffer_request_body: JSON,
        format: str = "json",
        **kwargs: Any
    ) -> JSON:
        """**Applies to**\ : S1 pricing tier.

        This API returns a FeatureCollection where each Feature is a buffer around the corresponding
        indexed Feature of the input. The buffer could be either on the outside or the inside of the
        provided Feature, depending on the distance provided in the input. There must be either one
        distance provided per Feature in the FeatureCollection  input, or if only one distance is
        provided, then that distance is applied to every Feature in the collection. The positive (or
        negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry
        with a circle of radius equal to the absolute value of the buffer distance. The buffer API
        always returns a polygonal result. The negative or zero-distance buffer of lines and points is
        always an empty polygon. The input may contain a collection of Point, MultiPoint, Polygon,
        MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.

        :param buffer_request_body: The FeatureCollection and the list of distances (one per feature or
         one for all features).
        :type buffer_request_body: JSON
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                buffer_request_body = {
                    "distances": [
                        0.0  # Optional. List of the distances to compute the buffer for,
                          one-to-one per Feature in the collection, or one for all Features in the
                          collection.
                    ],
                    "geometries": {
                        "features": [
                            {
                                "featureType": "str",  # Optional. The type of the
                                  feature. The value depends on the data model the current feature is
                                  part of. Some data models may have an empty value.
                                "geometry": {
                                    type: GeoJsonGeometry
                                },
                                "id": "str",  # Optional. Identifier for the feature.
                                "properties": {},  # Optional. Properties can contain
                                  any additional metadata about the ``Feature``. Value can be any JSON
                                  object or a JSON null value.
                                type: Feature
                            }
                        ],
                        type: FeatureCollection
                    }
                }

                # response body for status code(s): 200
                response.json() == {
                    "result": {
                        "features": [
                            {
                                "featureType": "str",  # Optional. The type of the
                                  feature. The value depends on the data model the current feature is
                                  part of. Some data models may have an empty value.
                                "geometry": {
                                    type: GeoJsonGeometry
                                },
                                "id": "str",  # Optional. Identifier for the feature.
                                "properties": {},  # Optional. Properties can contain
                                  any additional metadata about the ``Feature``. Value can be any JSON
                                  object or a JSON null value.
                                type: Feature
                            }
                        ],
                        type: FeatureCollection
                    },
                    "summary": {
                        "information": "str",  # Optional. The information about what
                          happened during the call.
                        "udid": "str"  # Optional. The udid for the user data if one exists.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = buffer_request_body

        request = build_spatial_post_buffer_request(
            api_version=api_version,
            format=format,
            content_type=content_type,
            json=_json,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_buffer(
        self,
        format: str = "json",
        *,
        udid: str,
        distances: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to**\ : S1 pricing tier.

        This API returns a FeatureCollection where each Feature is a buffer around the corresponding
        indexed Feature of the input. The buffer could be either on the outside or the inside of the
        provided Feature, depending on the distance provided in the input. There must be either one
        distance provided per Feature in the FeatureCollection  input, or if only one distance is
        provided, then that distance is applied to every Feature in the collection. The positive (or
        negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry
        with a circle of radius equal to the absolute value of the buffer distance. The buffer API
        always returns a polygonal result. The negative or zero-distance buffer of lines and points is
        always an empty polygon. The input features are provided by a GeoJSON file which is uploaded
        via `Data Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and
        referenced by a unique udid. The GeoJSON file may contain a collection of Point, MultiPoint,
        Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if
        provided.

        To test this API, you can upload the sample data from `Post Buffer API
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/postbuffer#examples>`_ examples(Request
        Body without distances array) via `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and replace the [udid]
        from the `sample request below
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/getbuffer#examples>`_ with the udid
        returned by Data Upload API.

        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword udid: The unique id returned from `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ after uploading a valid
         GeoJSON FeatureCollection object.  Please refer to `RFC 7946
         <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details. All the feature's properties
         should contain ``geometryId``\ , which is used for identifying the geometry and is
         case-sensitive.
        :paramtype udid: str
        :keyword distances: The list of distances (one per feature or one for all features), delimited
         by semicolons. For example, 12.34;-56.78. Positive distance will generate a buffer outside of
         the feature, whereas negative distance will generate a buffer inside of the feature. If the
         negative distance larger than the geometry itself, an empty polygon will be returned.
        :paramtype distances: str
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "result": {
                        "features": [
                            {
                                "featureType": "str",  # Optional. The type of the
                                  feature. The value depends on the data model the current feature is
                                  part of. Some data models may have an empty value.
                                "geometry": {
                                    type: GeoJsonGeometry
                                },
                                "id": "str",  # Optional. Identifier for the feature.
                                "properties": {},  # Optional. Properties can contain
                                  any additional metadata about the ``Feature``. Value can be any JSON
                                  object or a JSON null value.
                                type: Feature
                            }
                        ],
                        type: FeatureCollection
                    },
                    "summary": {
                        "information": "str",  # Optional. The information about what
                          happened during the call.
                        "udid": "str"  # Optional. The udid for the user data if one exists.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_spatial_get_buffer_request(
            api_version=api_version,
            format=format,
            udid=udid,
            distances=distances,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def post_closest_point(
        self,
        closest_point_request_body: JSON,
        format: str = "json",
        *,
        latitude: float,
        longitude: float,
        number_of_closest_points: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """**Applies to**\ : S1 pricing tier.

        This API returns the closest point between a base point and a given set of target points. The
        set of target points is provided by user data in post request body. The user data may only
        contain a collection of Point geometry. MultiPoint or other geometries will be ignored if
        provided. The algorithm does not take into account routing or traffic. The maximum number of
        points accepted is 100,000. Information returned includes closest point latitude, longitude,
        and distance in meters from the closest point.

        :param closest_point_request_body: The FeatureCollection of Point geometries from which closest
         point to source point should be determined. All the feature's properties should contain
         ``geometryId``\ , which is used for identifying the geometry and is case-sensitive.
        :type closest_point_request_body: JSON
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword latitude: The latitude of the location being passed.  Example: 48.36.
        :paramtype latitude: float
        :keyword longitude: The longitude of the location being passed.  Example: -124.63.
        :paramtype longitude: float
        :keyword number_of_closest_points: The number of closest points expected from response.
         Default: 1, minimum: 1 and maximum: 50. Default value is None.
        :paramtype number_of_closest_points: int
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                closest_point_request_body = {
                    "features": [
                        {
                            "featureType": "str",  # Optional. The type of the feature.
                              The value depends on the data model the current feature is part of. Some
                              data models may have an empty value.
                            "geometry": {
                                type: GeoJsonGeometry
                            },
                            "id": "str",  # Optional. Identifier for the feature.
                            "properties": {},  # Optional. Properties can contain any
                              additional metadata about the ``Feature``. Value can be any JSON object
                              or a JSON null value.
                            type: Feature
                        }
                    ],
                    type: FeatureCollection
                }

                # response body for status code(s): 200
                response.json() == {
                    "result": [
                        {
                            "distanceInMeters": 0.0,  # Optional. The distance in meters
                              from the source point to the closest point.
                            "geometryId": "str",  # Optional. The unique id identifies a
                              geometry.
                            "position": {
                                "lat": 0.0,  # Optional. Latitude property.
                                "lon": 0.0  # Optional. Longitude property.
                            }
                        }
                    ],
                    "summary": {
                        "information": "str",  # Optional. Processing information.
                        "sourcePoint": {
                            "lat": 0.0,  # Optional. Latitude property.
                            "lon": 0.0  # Optional. Longitude property.
                        },
                        "udid": "str"  # Optional. A unique data id (udid) for the uploaded
                          content.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = closest_point_request_body

        request = build_spatial_post_closest_point_request(
            api_version=api_version,
            format=format,
            content_type=content_type,
            latitude=latitude,
            longitude=longitude,
            json=_json,
            client_id=self._config.client_id,
            number_of_closest_points=number_of_closest_points,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_closest_point(
        self,
        format: str = "json",
        *,
        udid: str,
        latitude: float,
        longitude: float,
        number_of_closest_points: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """**Applies to**\ : S1 pricing tier.

        This API returns the closest point between a base point and a given set of points in the user
        uploaded data set identified by udid. The set of target points is provided by a GeoJSON file
        which is uploaded via `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and referenced by a
        unique udid. The GeoJSON file may only contain a collection of Point geometry. MultiPoint or
        other geometries will be ignored if provided. The maximum number of points accepted is 100,000.
        The algorithm does not take into account routing or traffic. Information returned includes
        closest point latitude, longitude, and distance in meters from the closest point.

        To test this API, you can upload the sample data from `Post Closest Point API
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/postclosestpoint#examples>`_
        examples(Request Body) via `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and replace the [udid]
        from the `sample request below
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/getclosestpoint#examples>`_ with the
        udid returned by Data Upload API.

        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword udid: The unique id returned from `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ after uploading a valid
         GeoJSON FeatureCollection object.  Please refer to `RFC 7946
         <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details. All the feature's properties
         should contain ``geometryId``\ , which is used for identifying the geometry and is
         case-sensitive.
        :paramtype udid: str
        :keyword latitude: The latitude of the location being passed.  Example: 48.36.
        :paramtype latitude: float
        :keyword longitude: The longitude of the location being passed.  Example: -124.63.
        :paramtype longitude: float
        :keyword number_of_closest_points: The number of closest points expected from response.
         Default: 1, minimum: 1 and maximum: 50. Default value is None.
        :paramtype number_of_closest_points: int
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "result": [
                        {
                            "distanceInMeters": 0.0,  # Optional. The distance in meters
                              from the source point to the closest point.
                            "geometryId": "str",  # Optional. The unique id identifies a
                              geometry.
                            "position": {
                                "lat": 0.0,  # Optional. Latitude property.
                                "lon": 0.0  # Optional. Longitude property.
                            }
                        }
                    ],
                    "summary": {
                        "information": "str",  # Optional. Processing information.
                        "sourcePoint": {
                            "lat": 0.0,  # Optional. Latitude property.
                            "lon": 0.0  # Optional. Longitude property.
                        },
                        "udid": "str"  # Optional. A unique data id (udid) for the uploaded
                          content.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_spatial_get_closest_point_request(
            api_version=api_version,
            format=format,
            udid=udid,
            latitude=latitude,
            longitude=longitude,
            client_id=self._config.client_id,
            number_of_closest_points=number_of_closest_points,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def post_point_in_polygon(
        self,
        point_in_polygon_request_body: JSON,
        format: str = "json",
        *,
        latitude: float,
        longitude: float,
        **kwargs: Any
    ) -> JSON:
        """**Applies to**\ : S1 pricing tier.

        This API returns a boolean value indicating whether a point is inside a set of polygons. The
        user data may contain Polygon and MultiPolygon geometries, other geometries will be ignored if
        provided. If the point is inside or on the boundary of one of these polygons, the value
        returned is true. In all other cases, the value returned is false. When the point is inside
        multiple polygons, the result will give intersecting geometries section to show all valid
        geometries (referenced by geometryId) in user data. The maximum number of vertices accepted to
        form a Polygon is 10,000.

        :param point_in_polygon_request_body: A FeatureCollection with a set of Polygon/MultiPolygon
         geometries. The maximum number of vertices accepted to form a Polygon is 10,000. All the
         feature's properties should contain ``geometryId``\ , which is used for identifying the
         geometry and is case-sensitive.
        :type point_in_polygon_request_body: JSON
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword latitude: The latitude of the location being passed.  Example: 48.36.
        :paramtype latitude: float
        :keyword longitude: The longitude of the location being passed.  Example: -124.63.
        :paramtype longitude: float
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                point_in_polygon_request_body = {
                    "features": [
                        {
                            "featureType": "str",  # Optional. The type of the feature.
                              The value depends on the data model the current feature is part of. Some
                              data models may have an empty value.
                            "geometry": {
                                type: GeoJsonGeometry
                            },
                            "id": "str",  # Optional. Identifier for the feature.
                            "properties": {},  # Optional. Properties can contain any
                              additional metadata about the ``Feature``. Value can be any JSON object
                              or a JSON null value.
                            type: Feature
                        }
                    ],
                    type: FeatureCollection
                }

                # response body for status code(s): 200
                response.json() == {
                    "result": {
                        "intersectingGeometries": [
                            "str"  # Optional. Geometries array.
                        ],
                        "pointInPolygons": bool  # Optional. Point In Polygons Property.
                    },
                    "summary": {
                        "information": "str",  # Optional. Processing information.
                        "sourcePoint": {
                            "lat": 0.0,  # Optional. Latitude property.
                            "lon": 0.0  # Optional. Longitude property.
                        },
                        "udid": "str"  # Optional. A unique data id (udid) for the uploaded
                          content. Udid is not applicable for POST spatial operations(set to null).
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = point_in_polygon_request_body

        request = build_spatial_post_point_in_polygon_request(
            api_version=api_version,
            format=format,
            content_type=content_type,
            latitude=latitude,
            longitude=longitude,
            json=_json,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def evaluate_point_in_polygon(
        self,
        format: str = "json",
        *,
        udid: str,
        latitude: float,
        longitude: float,
        **kwargs: Any
    ) -> JSON:
        """**Applies to**\ : S1 pricing tier.

        This API returns a boolean value indicating whether a point is inside a set of polygons. The
        set of polygons is provided by a GeoJSON file which is uploaded via `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and referenced by a
        unique udid. The GeoJSON file may contain Polygon and MultiPolygon geometries, other geometries
        will be ignored if provided. If the point is inside or on the boundary of one of these
        polygons, the value returned is true. In all other cases, the value returned is false. When the
        point is inside multiple polygons, the result will give intersecting geometries section to show
        all valid geometries(referenced by geometryId) in user data. The maximum number of vertices
        accepted to form a Polygon is 10,000.

        To test this API, you can upload the sample data from `Post Point In Polygon API
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/postpointinpolygon#examples>`_
        examples(Request Body) via `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and replace the [udid]
        from the `sample request below
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/getpointinpolygon#examples>`_ with the
        udid returned by Data Upload API.

        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword udid: The unique id returned from `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ after uploading a valid
         GeoJSON FeatureCollection object.  Please refer to `RFC 7946
         <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details. All the feature's properties
         should contain ``geometryId``\ , which is used for identifying the geometry and is
         case-sensitive.
        :paramtype udid: str
        :keyword latitude: The latitude of the location being passed.  Example: 48.36.
        :paramtype latitude: float
        :keyword longitude: The longitude of the location being passed.  Example: -124.63.
        :paramtype longitude: float
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "result": {
                        "intersectingGeometries": [
                            "str"  # Optional. Geometries array.
                        ],
                        "pointInPolygons": bool  # Optional. Point In Polygons Property.
                    },
                    "summary": {
                        "information": "str",  # Optional. Processing information.
                        "sourcePoint": {
                            "lat": 0.0,  # Optional. Latitude property.
                            "lon": 0.0  # Optional. Longitude property.
                        },
                        "udid": "str"  # Optional. A unique data id (udid) for the uploaded
                          content. Udid is not applicable for POST spatial operations(set to null).
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_spatial_evaluate_point_in_polygon_request(
            api_version=api_version,
            format=format,
            udid=udid,
            latitude=latitude,
            longitude=longitude,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_great_circle_distance(
        self,
        format: str = "json",
        *,
        query: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to**\ : S1 pricing tier.

        This API will return the great-circle or shortest distance between two points on the surface of
        a sphere, measured along the surface of the sphere.  This differs from calculating a straight
        line through the sphere's interior. This method is helpful for estimating travel distances for
        airplanes by calculating the shortest distance between airports.

        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str
        :keyword query: The Coordinates through which the distance is calculated, delimited by a colon.
         Two coordinates are required.  The first one is the source point coordinate and the last is the
         target point coordinate. For example, 47.622942,122.316456:57.673988,127.121513.
        :paramtype query: str
        :keyword api_version: Api Version. Default value is "1.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "result": {
                        "distanceInMeters": 0.0  # Optional. The great circle distance in
                          meters from the source point to the target point.
                    },
                    "summary": {
                        "sourcePoint": {
                            "lat": 0.0,  # Optional. Latitude property.
                            "lon": 0.0  # Optional. Longitude property.
                        },
                        "targetPoint": {
                            "lat": 0.0,  # Optional. Latitude property.
                            "lon": 0.0  # Optional. Longitude property.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "1.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_spatial_get_great_circle_distance_request(
            api_version=api_version,
            format=format,
            query=query,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class TilesetOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`tileset` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    async def _create_initial(
        self,
        *,
        dataset_id: str,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_tileset_create_request_initial(
            api_version=api_version,
            dataset_id=dataset_id,
            client_id=self._config.client_id,
            description=description,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))
            

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized



    @distributed_trace_async
    async def begin_create(
        self,
        *,
        dataset_id: str,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         `This <https://docs.microsoft.com/en-us/azure/azure-maps/creator-indoor-maps>`_ article
        introduces concepts and tools that apply to Azure Maps Creator.

        The Tileset Create API allows the caller to create a tileset from a dataset. A tileset contains
        a set of tiles that can be consumed
        from the `Get Map Tile </rest/api/maps/render/getmaptile>`_ to retrieve custom tiles. To make a
        dataset, use the
        `DataSet Create API </rest/api/maps/dataset/createpreview>`_.

        Submit Create Request
        ---------------------

        To create your tileset you will make a ``POST`` request with an empty body. The ``datasetId``
        query parameter will be
        used as the source of the tileset data.

        The Create Tileset API is a
        `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        :keyword dataset_id: The unique ``datasetId`` that the tileset create API uses to retrieve
         features to generate tiles. The ``datasetId`` must have been obtained from a successful
         `Dataset Create API <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_ call.
        :paramtype dataset_id: str
        :keyword description: User provided description of the tileset. Default value is None.
        :paramtype description: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
         for this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "operationId": "str",  # Optional. The Id for this long-running operation.
                    "status": "str",  # Optional. The status state of the request. Known values
                      are: "NotStarted", "Running", "Failed", "Succeeded".
                    "warning": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_initial(  # type: ignore
                dataset_id=dataset_id,
                description=description,
                api_version=api_version,
                cls=lambda x,y,z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop('error_map', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized


        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncLROBasePolling(
                lro_delay,
                lro_options={'final-state-via': 'location'},
                path_format_arguments=path_format_arguments,
                **kwargs
        ))  # type: AsyncPollingMethod
        elif polling is False: polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)



    @distributed_trace
    def list(
        self,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a list of all tilesets created.\ :raw-html-m2r:`<br>`
        :code:`<br>`.

        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "nextLink": "str",  # Optional. If present, the location of the next page of
                      data.
                    "tilesets": [
                        {
                            "bbox": [
                                0.0  # Optional. Bounding box which all features of
                                  the tileset lay within. Projection used - EPSG:3857. Format :
                                  'minLon, minLat, maxLon, maxLat'.
                            ],
                            "datasetId": "str",  # Optional. The unique dataset Id used
                              to create the tileset.
                            "description": "str",  # Optional. The description the caller
                              provided when creating the tileset. Maximum length 1024 characters.
                            "maxZoom": 0,  # Optional. The highest tile zoom level tile
                              generated for the tileset.
                            "minZoom": 0,  # Optional. The lowest tile zoom level tile
                              generated for the tileset.
                            "ontology": "str",  # Optional. The ontology version of this
                              dataset.
                            "tilesetId": "str"  # Optional. The unique tileset id for the
                              tileset.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_tileset_list_request(
                    api_version=api_version,
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_tileset_list_request(
                    client_id=self._config.client_id,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["tilesets"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )


    @distributed_trace_async
    async def get(
        self,
        tileset_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a tileset.

        :param tileset_id: The Tileset Id.
        :type tileset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "bbox": [
                        0.0  # Optional. Bounding box which all features of the tileset lay
                          within. Projection used - EPSG:3857. Format : 'minLon, minLat, maxLon,
                          maxLat'.
                    ],
                    "datasetId": "str",  # Optional. The unique dataset Id used to create the
                      tileset.
                    "description": "str",  # Optional. The description the caller provided when
                      creating the tileset. Maximum length 1024 characters.
                    "maxZoom": 0,  # Optional. The highest tile zoom level tile generated for the
                      tileset.
                    "minZoom": 0,  # Optional. The lowest tile zoom level tile generated for the
                      tileset.
                    "ontology": "str",  # Optional. The ontology version of this dataset.
                    "tilesetId": "str"  # Optional. The unique tileset id for the tileset.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_tileset_get_request(
            tileset_id=tileset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        tileset_id: str,
        **kwargs: Any
    ) -> None:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to delete a created tileset.:code:`<br>`\ :raw-html-m2r:`<br>`
        You can use this API if a tileset is no longer needed.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your content you will issue a ``DELETE`` request where the path will contain the
        ``tilesetId`` of the tileset to delete.:code:`<br>`

        Delete request "Successful"
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~

        The Tileset Delete API returns a HTTP ``204 No Content`` response with an empty body, if the
        tileset was deleted successfully.:code:`<br>`

        Delete request "Failed"
        ~~~~~~~~~~~~~~~~~~~~~~~

        A HTTP ``400 Bad Request`` error response will be returned if the tileset with the passed-in
        ``tilesetId`` is not found.

        Here is a sample error response:

        :code:`<br>`

        .. code-block:: json

           {
             "error": {
                 "code": "400 BadRequest",
                 "message": "Bad request - Tileset Id: d85b5b27-5fc4-4599-8b50-47160e90f8ce does not
        exist."
             }
           }.

        :param tileset_id: The Tileset Id.
        :type tileset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_tileset_delete_request(
            tileset_id=tileset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_operation(
        self,
        operation_id: str,
        **kwargs: Any
    ) -> JSON:
        """This path will be obtained from a call to /tilesets/create.  While in progress, an http200 will
        be returned with no extra headers -  followed by an http200 with Resource-Location header once
        successfully completed.

        :param operation_id: The ID to query the status for the tileset create/import request.
        :type operation_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "created": "2020-02-20 00:00:00",  # Optional. The created timestamp.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "operationId": "str",  # Optional. The Id for this long-running operation.
                    "status": "str",  # Optional. The status state of the request. Known values
                      are: "NotStarted", "Running", "Failed", "Succeeded".
                    "warning": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_tileset_get_operation_request(
            operation_id=operation_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)


class WFSOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.creator.aio.CreatorClient`'s
        :attr:`wfs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def get_landing_page(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Landing Page API provides links to the API definition, the Conformance statements  and
        the metadata about the feature data in this dataset.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "links": [
                        {
                            "href": "str",  # Required. The link target.
                            "hreflang": "str",  # Optional. A hint indicating what the
                              language of the result of dereferencing the link should be.
                            "rel": "str",  # Optional. The relation type.
                            "title": "str",  # Optional. Used to label the destination of
                              a link such that it can be used as a human-readable identifier (e.g., a
                              menu entry) in the language indicated by the Content-Language header
                              field (if present).
                            "type": "str"  # Optional. A hint indicating what the media
                              type of the result of dereferencing the link should be.
                        }
                    ],
                    "ontology": "str"  # Optional. The ontology version of this dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_wfs_get_landing_page_request(
            dataset_id=dataset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def list_conformance(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Requirements Classes lists all requirements classes specified in the standard that the
        server conforms to.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "conformsTo": [
                        "str"  # Required. List of requirements classes that the server
                          conforms to.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_wfs_list_conformance_request(
            dataset_id=dataset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_collections(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Collections Description API provides descriptions of all the collections in a given
        dataset.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "collections": [
                        {
                            "description": "str",  # Optional. a description of the
                              features in the collection.
                            "links": [
                                {
                                    "href": "str",  # Required. The link target.
                                    "hreflang": "str",  # Optional. A hint
                                      indicating what the language of the result of dereferencing the
                                      link should be.
                                    "rel": "str",  # Optional. The relation type.
                                    "title": "str",  # Optional. Used to label
                                      the destination of a link such that it can be used as a
                                      human-readable identifier (e.g., a menu entry) in the language
                                      indicated by the Content-Language header field (if present).
                                    "type": "str"  # Optional. A hint indicating
                                      what the media type of the result of dereferencing the link
                                      should be.
                                }
                            ],
                            "name": "str",  # Required. identifier of the collection
                              used, for example, in URIs.
                            "ontology": "str",  # Optional. The ontology version of this
                              dataset.
                            "title": "str"  # Optional. human readable title of the
                              collection.
                        }
                    ],
                    "links": [
                        {
                            "href": "str",  # Required. The link target.
                            "hreflang": "str",  # Optional. A hint indicating what the
                              language of the result of dereferencing the link should be.
                            "rel": "str",  # Optional. The relation type.
                            "title": "str",  # Optional. Used to label the destination of
                              a link such that it can be used as a human-readable identifier (e.g., a
                              menu entry) in the language indicated by the Content-Language header
                              field (if present).
                            "type": "str"  # Optional. A hint indicating what the media
                              type of the result of dereferencing the link should be.
                        }
                    ],
                    "ontology": "str"  # Optional. The ontology version of this dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_wfs_get_collections_request(
            dataset_id=dataset_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_collection(
        self,
        dataset_id: str,
        collection_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Description API provides the description of a given collection. It includes the
        links to the operations that can be performed on the collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "description": "str",  # Optional. a description of the features in the
                      collection.
                    "links": [
                        {
                            "href": "str",  # Required. The link target.
                            "hreflang": "str",  # Optional. A hint indicating what the
                              language of the result of dereferencing the link should be.
                            "rel": "str",  # Optional. The relation type.
                            "title": "str",  # Optional. Used to label the destination of
                              a link such that it can be used as a human-readable identifier (e.g., a
                              menu entry) in the language indicated by the Content-Language header
                              field (if present).
                            "type": "str"  # Optional. A hint indicating what the media
                              type of the result of dereferencing the link should be.
                        }
                    ],
                    "name": "str",  # Required. identifier of the collection used, for example,
                      in URIs.
                    "ontology": "str",  # Optional. The ontology version of this dataset.
                    "title": "str"  # Optional. human readable title of the collection.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_wfs_get_collection_request(
            dataset_id=dataset_id,
            collection_id=collection_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_collection_definition(
        self,
        dataset_id: str,
        collection_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         `This <https://docs.microsoft.com/en-us/azure/azure-maps/creator-indoor-maps>`_ article
        introduces concepts and tools that apply to Azure Maps Creator. WFS API follows the `Open
        Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Definition API provides the detailed data model of a given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "description": "str",  # Optional. describes the collection.
                    "featureTypes": [
                        "str"  # Required. type of features returned.
                    ],
                    "geometryType": "str",  # Required. type of geometry returned. Known values
                      are: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon",
                      "MultiPolygon", "GeometryCollection".
                    "idPrefix": "str",  # Required. prefix of the collection used.
                    "links": [
                        {
                            "href": "str",  # Required. The link target.
                            "hreflang": "str",  # Optional. A hint indicating what the
                              language of the result of dereferencing the link should be.
                            "rel": "str",  # Optional. The relation type.
                            "title": "str",  # Optional. Used to label the destination of
                              a link such that it can be used as a human-readable identifier (e.g., a
                              menu entry) in the language indicated by the Content-Language header
                              field (if present).
                            "type": "str"  # Optional. A hint indicating what the media
                              type of the result of dereferencing the link should be.
                        }
                    ],
                    "name": "str",  # Required. identifier of the collection used, for example,
                      in URIs.
                    "ontology": "str",  # Optional. The ontology version of this dataset.
                    "properties": [
                        {
                            "name": "str",  # Required. name of attribute.
                            "required": bool,  # Required. is attribute required.
                            "type": {}  # Required. type of attribute.
                        }
                    ],
                    "title": "str"  # Optional. title of collection.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_wfs_get_collection_definition_request(
            dataset_id=dataset_id,
            collection_id=collection_id,
            api_version=api_version,
            client_id=self._config.client_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_features(
        self,
        dataset_id: str,
        collection_id: str,
        *,
        limit: Optional[int] = None,
        bounding_box: Optional[List[float]] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Features API returns the list of features in the given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword limit: The optional limit parameter limits the number of features that are presented
         in the response document.
         Only features that are on the first level of the collection in the response document are
         counted. Nested objects contained within the explicitly requested features shall not be
         counted.


         * Minimum = 1 * Maximum = 500 * Default = 10. Default value is None.
        :paramtype limit: int
        :keyword bounding_box: Only features that have a geometry that intersects the supplied bounding
         box are selected.


         * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Upper right
         corner, coordinate axis 1 * Upper right corner, coordinate axis 2
           The coordinate reference system of the values is WGS84 longitude/latitude
         (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system
         is specified in the parameter ``bbox-crs``.
           For WGS84 longitude/latitude the values are in most cases the sequence of minimum longitude,
         minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans
         the antimeridian the first value (west-most box edge) is larger than the third value (east-most
         box edge). Default value is None.
        :paramtype bounding_box: list[float]
        :keyword filter: Filter expression to search for features with specific property values in a
         given collection. Only feature properties of scalar type and equals operator are supported.
         This is a special parameter where the parameter name is a case sensitive property name. The
         scheme for this parameter is {property name}={property value}. Unless "filter" is one of the
         property names in the collection, "filter" should not be used as a parameter name. To search
         for features with "name" property value "21N13", use "name=21N13".
         Multiple filters are supported and should be represented as multiple query parameters. E.g.,
         :code:`<property1>`=:code:`<value1>`&:code:`<property2>`=:code:`<value2>` String values are
         case sensitive. Default value is None.
        :paramtype filter: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "features": [
                        {
                            "featureType": "str",  # Optional. The type of the feature.
                              The value depends on the data model the current feature is part of. Some
                              data models may have an empty value.
                            "geometry": {
                                type: GeoJsonGeometry
                            },
                            "id": "str",  # Optional. Identifier for the feature.
                            "properties": {},  # Optional. Properties can contain any
                              additional metadata about the ``Feature``. Value can be any JSON object
                              or a JSON null value.
                            type: Feature
                        }
                    ],
                    "links": [
                        {
                            "href": "str",  # Required. The link target.
                            "hreflang": "str",  # Optional. A hint indicating what the
                              language of the result of dereferencing the link should be.
                            "rel": "str",  # Optional. The relation type.
                            "title": "str",  # Optional. Used to label the destination of
                              a link such that it can be used as a human-readable identifier (e.g., a
                              menu entry) in the language indicated by the Content-Language header
                              field (if present).
                            "type": "str"  # Optional. A hint indicating what the media
                              type of the result of dereferencing the link should be.
                        }
                    ],
                    "numberReturned": 0,  # Optional. Number of returned features.
                    "ontology": "str",  # Optional. The ontology version of this dataset.
                    "type": "str"  # Optional. Specifies the ``GeoJSON`` type: FeatureCollection.
                      Known values are: "Point", "MultiPoint", "LineString", "MultiLineString",
                      "Polygon", "MultiPolygon", "GeometryCollection", "Feature", "FeatureCollection".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_wfs_get_features_request(
            dataset_id=dataset_id,
            collection_id=collection_id,
            api_version=api_version,
            client_id=self._config.client_id,
            limit=limit,
            bounding_box=bounding_box,
            filter=filter,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_feature(
        self,
        dataset_id: str,
        collection_id: str,
        feature_id: str,
        **kwargs: Any
    ) -> JSON:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Feature API returns the feature identified by the provided id in the given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "feature": {
                        "featureType": "str",  # Optional. The type of the feature. The value
                          depends on the data model the current feature is part of. Some data models
                          may have an empty value.
                        "geometry": {
                            type: GeoJsonGeometry
                        },
                        "id": "str",  # Optional. Identifier for the feature.
                        "properties": {},  # Optional. Properties can contain any additional
                          metadata about the ``Feature``. Value can be any JSON object or a JSON null
                          value.
                        type: Feature
                    },
                    "links": [
                        {
                            "href": "str",  # Required. The link target.
                            "hreflang": "str",  # Optional. A hint indicating what the
                              language of the result of dereferencing the link should be.
                            "rel": "str",  # Optional. The relation type.
                            "title": "str",  # Optional. Used to label the destination of
                              a link such that it can be used as a human-readable identifier (e.g., a
                              menu entry) in the language indicated by the Content-Language header
                              field (if present).
                            "type": "str"  # Optional. A hint indicating what the media
                              type of the result of dereferencing the link should be.
                        }
                    ],
                    "ontology": "str"  # Optional. The ontology version of this dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_wfs_get_feature_request(
            dataset_id=dataset_id,
            collection_id=collection_id,
            feature_id=feature_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete_feature(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        collection_id: str,
        feature_id: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Delete Feature API deletes the feature identified by the provided id in the given
        collection. At this point this API supports only facility features. Deleting a facility feature
        deletes all the child features of that facility recursively.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword api_version: Api Version. Default value is "2.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_wfs_delete_feature_request(
            dataset_id=dataset_id,
            collection_id=collection_id,
            feature_id=feature_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "geography": self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


